package soundBites;

import java.util.Arrays;

import soundBites.jAudio.JAudioFFT;
import soundBites.jAudio.RMS;
import soundBites.jAudio.SpectralCentroid;
import soundBites.jAudio.SpectralFlux;
import soundBites.jAudio.SpectralRolloffPoint;

public class AnalysisInterface {
 
  // All of these are accounted for here. Name differences:
  //   - Energy -> RMS()
  //   - Frequency roll-off -> spectralRolloff()
  //   - Spectral asymmetry -> spectralVariability()
  


  public static final int WINDOW_SIZE_SAMPLES = 256; //Le estamos metiendo hopSize
  public static final int SAMPLE_RATE = 16000; //original 44100
  
  /*
   * jAudio
   * A standard measure for the volume of the audio signal.
   */
  public static double RMS(double[] window)
  {
    // instantiates a new RMS() and returns the first (and only) value in the
    // double[] generated by extractFeature()
    
    return (new RMS()).extractFeature(window, 0.0, null)[0];
  }
  
  /*
   * @author wab108
   * 
   * jAudio does have this, but I did it myself before I realised it did.
   */
  public static int zeroCrossRate(double[] window)
  {
    int acc = 0;
    double lastShort = 0;
    
    for(double s : window)
    {
      if(lastShort == 0 && s != 0)
      {
        acc++;
      } else if(lastShort < 0 && s > 0)
      {
        acc++;
      } else if(lastShort > 0 && s < 0)
      {
        acc++;
      }
      
      lastShort = s;
    }
    
    return acc;
  }
  
  /*
   * @author wab108
   * 
   * @param window           The audio window.
   * @param separationPoint  The point at which the ratio for above and below
   *                           is calculated; e.g. separationPoint = 0.5 
   *                           calculates the ratio of energy above and below
   *                           the halfway point on the spectrum.
   * 
   * From Spectral and Textural Feature-Based System for Automatic Detection
   * of Fricatives and Affricates [Ruinsky et al.]. Gives the proportion of
   * energy in high bands versus low bands (this is used in speech recognition
   * to distinguish fricatives and affricates from lower-voiced phonemes).
   */
  public static double bandEnergyRatio(double[] window, double separationPoint)
  {
    double[] powSpectrum = null;
    try
    {
      powSpectrum = (new JAudioFFT(window, null, false, true)).getPowerSpectrum();
    } catch (Exception e)
    {
      e.printStackTrace();
    }

    int binLimit = (int) (powSpectrum.length * separationPoint);
    double belowSum = 0.0, aboveSum = 0.0;
    
    for(int i=0;i<binLimit;i++)
      belowSum += powSpectrum[i];
    
    for(int i=binLimit;i<powSpectrum.length;i++)
      aboveSum += powSpectrum[i];
    
    if(aboveSum==0 || belowSum==0) {
    	return 0;
    }else {
    	return aboveSum / belowSum;
    }
    
    
  }
  
  /*
   * @author wab108
   * 
   * Uses jAudio's power spectrum. The spectral flatness measure is:
   * 
   * geometricMean(powerSpectrum)/arithmeticMean(powerSpectrum)
   * 
   * As given by Transform coding of audio signals using perceptual noise
   * criteria [Johnston].
   */
  public static double spectralFlatness(double[] window)
  {
    double[] ps = null;
    
    try
    {
      ps = (new JAudioFFT(window, null, false, true)).getPowerSpectrum();
    } catch (Exception e)
    {
      e.printStackTrace();
    }
    
    double geometricMean = 1.0, arithmeticMean = 0.0;
    for(int i=0;i<ps.length;i++)
    {
      geometricMean *= ps[i];
      arithmeticMean += ps[i];
    }
    geometricMean = Math.pow(geometricMean, 1 / WINDOW_SIZE_SAMPLES);
    arithmeticMean /= WINDOW_SIZE_SAMPLES;
    
    if(geometricMean==0 || arithmeticMean==0) {
    	return 0;
    }else {    
    	return geometricMean/arithmeticMean;
    }
  }
  
  /*
   * jAudio
   */
  public static double spectralRolloff(double[] window)
  {
    double[][] ps = new double[1][WINDOW_SIZE_SAMPLES];
    
    try
    {
      ps[0] = (new JAudioFFT(window, null, false, true)).getPowerSpectrum();
    } catch (Exception e)
    {
      e.printStackTrace();
    }
    
    return (new SpectralRolloffPoint()).extractFeature(null, 0.0, ps)[0];
  }
  
  /*
   * Comirva
   * 
   * @return The distance between the highest and the lowest bands with signal
   * in them; i.e. the index of the highest above-threshold analysis band
   * minus the index of the lowest above-threshold analysis band. For a signal
   * with none or only one of these, the value is 0; for two adjacent ones, it
   * is 1.
   * 
   * The magnitude transform is used, as opposed to the normalised power
   * transform for the MFCC calculations. The magnitude transform is the
   * 'standard' FFT - note that the power transform provides the same
   * coefficients, but squared.
   * 
   * Once again, the "Hanning" window is actually the Hann window.
   */
  private static double SB_NOISE_THRESHOLD = 10.0;
  
  public static int spectralBandwidth(double[] window)
  {
    
    FFT magnitudeFFT = new FFT(FFT.FFT_MAGNITUDE, WINDOW_SIZE_SAMPLES, FFT.WND_HANNING);

    magnitudeFFT.transform(window, null);
    
    int lowest = 0, highest = 0;
    boolean lowWasSet = false;
    
    for(int i=0;i<window.length;i++)
    {
      if(window[i]>SB_NOISE_THRESHOLD)
      {
        if(!lowWasSet)
        {
          lowest = i;
          lowWasSet = true;
        }
        highest = i;
      }
    }
    
    return highest - lowest;
  }
  
  /*
   * jAudio
   * 
   * Splits the window in two and calculates the flux from the first to the
   * second.
   */
  public static double spectralFlux(double[] window)
  {
    double[][] mses;
    mses = splitWindow(window);
    
    return (new SpectralFlux()).extractFeature(null, 0.0, mses)[0];
  }
  
  public static double spectralCentroid(double[] window)
  {
    double[][] ps = new double[1][WINDOW_SIZE_SAMPLES];
    
    try
    {
      ps[0] = (new JAudioFFT(window, null, false, true)).getPowerSpectrum();
    } catch (Exception e)
    {
      e.printStackTrace();
    }
    
    return (new SpectralCentroid()).extractFeature(null, 0.0, ps)[0];
  }
  
//  public static double mean(short[] window)
//  {
//    return 0.0;
//  }
  
  /*
   * MFCC calculator
   */
  /*
  private static final float MFCC_SAMPLERATE = SAMPLE_RATE; // unlikely to change
  private static final int MFCC_WINDOWSIZE = WINDOW_SIZE_SAMPLES; // should probably correspond with what's being used for MP
  private static final int MFCC_NUMBERCOEFFICIENTS = 13; // liable to change. Discarded first coefficient = 12 total.
  private static final boolean MFCC_USEFIRSTCOEFFICIENT = false; // it's generally a very large value; it measures a global offset (DC) effect
  private static final double MFCC_MINFREQ = 20; //  
  private static final double MFCC_MAXFREQ = 2000; // 20-2000 is probably a sensible range here in light of the fact I'm trying to profile the lower band
  private static final int MFCC_NUMBERFILTERS = 40; // Explanation of the significance at http://dsp.stackexchange.com/a/362
  
  
  // uses Hann window, by default
  private static MFCC mfcc = new MFCC(
    MFCC_SAMPLERATE,
    MFCC_WINDOWSIZE,
    MFCC_NUMBERCOEFFICIENTS,
    MFCC_USEFIRSTCOEFFICIENT,
    MFCC_MINFREQ,
    MFCC_MAXFREQ,
    MFCC_NUMBERFILTERS
    );
  
  private static MFCC mfccHalfWindowSize = new MFCC(
    MFCC_SAMPLERATE,
    MFCC_WINDOWSIZE / 2,
    MFCC_NUMBERCOEFFICIENTS,
    MFCC_USEFIRSTCOEFFICIENT,
    MFCC_MINFREQ,
    MFCC_MAXFREQ,
    MFCC_NUMBERFILTERS
    );
*/
  
  /*
   * Java does not allow arrays of generics:
   */
  private static double[][] splitWindow(double[] window) throws IllegalArgumentException
  {
    if(window.length%2 != 0)
    {
      throw new IllegalArgumentException("Number of samples in window is not even.");
    }
    
    double[][] ret = new double[2][window.length/2];
    
    ret[0] = Arrays.copyOfRange(window, 0, window.length/2);
    ret[1] = Arrays.copyOfRange(window, window.length/2, window.length);
    
    return ret;
  }
}
